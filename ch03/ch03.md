### 1. 기이한 이름

- 함수, 모듈 변수, 클래스는 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야하는지 명확히 알 수 있도록 수정
- 마땅한 이름이 떠오리지 않는다면 설계의 문제일 수도 있음.
- 함수 선언, 변수 이름, 필드 이름 바꾸기와 같은 리팩터링 기법 이용됨.

```jsx
이름을 지을 때 비슷한 이름 parameter가 차이난다던가? 사용하는 곳이 다르다던가 로직이 살작 다르다던가

```

### 2. 중복 코드

- 코드 중복은 사용할 떄나 수정할 때 번거룬 작업이 생김.
- 함수 추출, 메서드 올리기, 문장 슬라이드와 같은 리팩터링 기법 이용됨.

```jsx

```

### 3. 긴 함수

- 코드가 짧으면(간접 호출)의 장점 : 코드를 이해하고, 공유하고, 선택하기 쉬워진다.
- 단점 : 서브루틴을 호출하는 비용이 크다(요즘은 여러 언어가 이 문제를 해결해 준다.)
- 이름을 잘 만들어 이해를 올리고, 주석을 없애는 것이 좋다.
- 함수 이름은 함수의 목적(의도)가 드러나게 짓는다.
- 함수 추출하기, 임시변수를 질의 함수로 바꾸기, 매개변수 객체 만들기, 조건문 분해하기, 조건문 다형성으로 바꾸기, 함수를 명령으로 바꾸기

```jsx
함수를 명령으로 바꾸기?
```

### 4. 긴 매개변수 목록

- 매개변수 목록이 길어지면 코드 이해가 어렵다.
- 매개변수를 질의 함수로 치환, 객체 통째로 넘기기, 매개변수 객체 만들기, 플래그 인수 제거하기, 여러 함수를 클래스로 묶기

### 5. 전역 데이터

- 전역 데이터는 어디에서나 접근 가능해 누가 값을 바꿧는지 찾아낼 메커니즘이 없다.
- 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견하면 → 전역 변수 캡슐화하기로 접근 통제
→ 싱글톤 패턴//

### 6. 가변 데이터

- 코드의 다른 곳에서 값 변경이 미치는 영향을 다 고려하기 쉽지않음
- 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 감시나 개선이 쉬워짐
- 변수 캡슐화, 문장 슬라이드, 세터 제거, 파생 변수를 질의 함수로 변경, 여러 함수를 클래스로 묶기, 여러 함수를 변화 함수로 묶기

### 7. 뒤엉킨 변경

- 소프트웨어의 구조 변경하기 쉬운 형태로 만들어야함. → 한 부분만 수정하고 싶을 때 수정을 할 수 있도록 유지(단일 책임 원칙(SRP))
- 순차적으로 실행되는 경우 → 단계 쪼개기, 여러 곳에서 호출 → 새로운 클래스로 옮김

### 8. 산탄총 수술

- 코드 변경시 자잘하게 수정해야 하는 클래스 많은 경우
→ 수정 부분을 찾기도 어렵고 수정해야 할 곳을 지나치기 쉽다.
- 함수 옮기기, 필드 옮기기로 → 한 모듈에 또는 여러 함수를 클래스로 묶기, 함수 인라인하기도 좋다.

### 9. 기능 편애

- 자기가 속한 모듈의 함수나 데이터보다 다름 도율의 함수나 데이터와 상호작용 할 일이 많을 때
→ 함수를 여러개로 나눠거 적절한 모듈(클래스)로 옮기기

### 10. 데이터 뭉치

- 데이터 항목이 서너개가 함께 뭉쳐다니면 → 클래스(매개변수)로 묶어버리기
- 데이터 하나를 제외하면 의미가 현저히 줄어드는 경우 →

### 11. 기본형 집착

- 기본형(int, float, str 등) 사용에 오류가 있을 수도 있다. 날짜, 화폐, 구간을 직접 정의해서 사용
- 기본형을 객체로 바꾸기, 조건부 로직을 다형성으로 바꾸기(기본형 그룹도 데이터 뭉치로 볼 수있다)

### 12. 반복되는 switch문

- 조건절 추가나 변경시 모든 switch문 수정이 필요하다 → switch문 다형성으로 바꾸기

### 13. 반복문

- 파이프라인으로 바꾸기

### 14. 성의 없는 요소

- 리팩토링 후 기능이 현저히 적은 클래스나 모듈은 제거하는 작업이 필요

### 15. 추측성 일반화

- '나중에 필요할 거야'→ 이해나 관리가 어려워 진다. 바로 치워 버리자
- 계층 합치기, 함수 인라인하기, 클래스 인라인 하기, 죽은 코드 제거하기

```jsx
function A(a, b, d):
	a += b **2 +d
	return a

```

### 16. 임시 필드

- 특정 상황에서만 값이 설정되는 필드를 가진 클래스 → 일반적으로 객체의 필드가 다 채워져있을 것이라고 생각되는것과 반대
- 추출하여 함수를 옮기거나, 사용하기 전 체크하는 로직을 만들어 유효하지 않을 때 사용할 대안 클래스를 만들어야 함.

### 17. 메시지 체인

- 한 객체가 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드 getSomething().get~~().get~~~()
- 위임 숨기기로 해결

### 18. 중개자

- 외부로부터 세부사항을 숨겨주는 캡슐화가 있다. 캡슐화에서 위임이 자주 활용됨.
- 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하면, 중개자 제거하기를 활용해 객체와 직접 소통하게 하자

```jsx
위임은 좋은 것?
```

### 19. 내부자 거래

- 모듈 간 클래스 간 결합도를 최소로 줄이고 투명하게 처리해야함
→ 함수 옯기기나 필드 옮기기로
- 부모 자식간 의도치 않은 결합↑
→ 서브클래스 or 슈퍼클래스를 위임으로 바꾸기

```jsx
서브클래스를 위임으로, 슈퍼클래스를 위임으로
```

### 20. 거대한 클래스

- 한 클래스가 너무 많은 일을 하면 필드가 많아지고 중복 코드가 생기기 쉽다
→ 클래스, 슈퍼클래스 추출

### 21. 서로 다른 인터페이스의 대안 클래스들

- 인터페이스를 맞추기 위해서 함수 선언 바꾸기, 클래스 옮기고 합치기
- 파사드 패턴

### 22. 데이터 클래스

- 데이터 클래스 : 데이터 필드와 getter/setter로만 구성된 클래스
→ 메서드를 찾아서 이 클래스로 옮기기(함수 옮기기) 등으로 옮김
- 일반적으로 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호
→ 저장용으로만 쓴다면 immutable로 클래스화 할 필요 x

### 23. 상속 포기

- 부모의 유산을 원치 않거나 필요 없다면 → 계층구조 설계를 다시 확인해야 함
→ 서브클래스 새로 만들어 메서드 내리고 필드 내리고, 부모의 필드와 매서드를 내린다.

### 24. 주석

- 대부분의 경우 주석이 필요 없다. 주석이 필요하다고 생각되는 경우 리팩터링 해보자
